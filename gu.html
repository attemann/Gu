<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Janus GPS Fix Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        
        .controls {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .status-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-online {
            background-color: #27ae60;
        }
        
        .status-offline {
            background-color: #e74c3c;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn.clear {
            background-color: #e74c3c;
        }
        
        .btn.clear:hover {
            background-color: #c0392b;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
        }
        
        .map-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            padding: 0px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 0; /* Allow flex item to shrink */
        }
        
        .sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .legend {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .legend h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #333;
        }
        
        .legend-ring {
            width: 16px;
            height: 16px;
            border: 2px solid;
            border-radius: 50%;
            margin-right: 10px;
            background: transparent;
        }
        
        .current-data {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .current-data h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .data-label {
            color: #666;
        }
        
        .data-value {
            font-weight: bold;
            color: #333;
        }
        
        #canvas {
            border: 1px solid #ddd;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }
        
        .canvas-info {
            text-align: center;
            margin: 10px 20px;
            font-size: 12px;
            color: #666;
        }
        
        .fix-data-bar {
            background: white;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }
        
        .fix-data-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .fix-data-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            min-width: 35px;
        }
        
        .fix-data-value {
            font-size: 13px;
            font-weight: bold;
            color: #2c3e50;
            font-family: monospace;
            min-width: 60px;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                flex-direction: row;
            }
            
            .legend, .current-data {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Janus GPS Fix Visualization</h1>
        </div>
        
        <div class="controls">
            <div class="status-info">
                <span>
                    <span id="connection-status" class="status-indicator status-offline"></span>
                    <span id="connection-text">Connecting...</span>
                </span>
                <span>
                    <span id="websocket-status" class="status-indicator status-offline"></span>
                    <span id="websocket-text">WebSocket: Disconnected</span>
                </span>
                <span id="fix-count">Fixes: 0</span>
                <span id="last-update">Last updated: Never</span>
            </div>
            <div class="button-group">
                <button class="btn" onclick="fetchData()">Refresh HTTP</button>
                <button class="btn" onclick="initWebSocket()">Reconnect WS</button>
                <button class="btn" onclick="testConnectivity()">Test Connection</button>
                <button class="btn clear" onclick="clearFixes()">Clear All</button>
                <button class="btn" onclick="centerView()">Center View</button>
            </div>
        </div>
        
        <div class="fix-data-bar">
            <div class="fix-data-group">
                <span class="fix-data-label">Lat:</span>
                <span class="fix-data-value" id="current-lat">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">Lon:</span>
                <span class="fix-data-value" id="current-lon">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">Ele:</span>
                <span class="fix-data-value" id="current-ele">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">Sats:</span>
                <span class="fix-data-value" id="current-siv">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">Type:</span>
                <span class="fix-data-value" id="current-type">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">HDOP:</span>
                <span class="fix-data-value" id="current-hdop">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">RSSI:</span>
                <span class="fix-data-value" id="current-rssi">--</span>
            </div>
            <div class="fix-data-group">
                <span class="fix-data-label">Time:</span>
                <span class="fix-data-value" id="current-time">--</span>
            </div>
        </div>        <div class="map-container">
            <canvas id="canvas"></canvas>
            <div class="canvas-info">
                Zoom: Mouse wheel | Pan: Click and drag | Each ring = 1 meter
            </div>
        </div>
    </div>

    <script>
        // Auto-detect ESP IP or use default
        let ESP_IP = '192.168.4.1';
        
        // Try to detect if we're being served from the ESP itself
        if (window.location.hostname && window.location.hostname !== '127.0.0.1' && window.location.hostname !== 'localhost') {
            ESP_IP = window.location.hostname;
            console.log('Detected ESP IP from hostname:', ESP_IP);
        }
        
        let updateInterval;
        let canvas, ctx;
        let fixes = [];
        let centerLat = null, centerLon = null;
        let scale = 200; // pixels per meter
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        
        // WebSocket variables
        let websocket = null;
        let wsReconnectInterval = null;
        let wsReconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        
        // Stability and drift monitoring
        let stabilityMetrics = {
            shortTerm: { fixes: [], window: 10 }, // Last 10 fixes
            oneMinute: { fixes: [], window: 60000 }, // 1 minute in ms
            fiveMinute: { fixes: [], window: 300000 }, // 5 minutes in ms
            oneHour: { fixes: [], window: 3600000 } // 1 hour in ms
        };
        
        // Pie chart variables (now drawn on main canvas)
        let fixTypeStats = {};
        
        // Stability data for canvas display
        let stabilityData = {
            short: '--',
            oneMin: '--',
            fiveMin: '--',
            oneHour: '--',
            driftOneMin: '--',
            driftFiveMin: '--',
            driftOneHour: '--'
        };
        
        // Fix type colors
        const fixColors = {
            0: '#e74c3c', // No Fix - Red
            1: '#f39c12', // Dead Reckoning - Orange
            2: '#f1c40f', // 2D Fix - Yellow
            3: '#27ae60', // 3D Fix - Green
            4: '#3498db', // GNSS + Dead Reckoning - Blue
            5: '#9b59b6'  // Time Only - Purple
        };
        
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to use available width
            resizeCanvas();
            
            // Mouse events for pan and zoom
            canvas.addEventListener('mousedown', startDrag);
            canvas.addEventListener('mousemove', drag);
            canvas.addEventListener('mouseup', endDrag);
            canvas.addEventListener('wheel', zoom);
            canvas.addEventListener('mouseleave', endDrag);
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth; // Use full container width to match top bars
            const containerHeight = Math.max(400, window.innerHeight - 300); // Responsive height
            
            // Set canvas display size
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';
            
            // Set canvas resolution (for crisp rendering)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = containerWidth * dpr;
            canvas.height = containerHeight * dpr;
            
            // Scale the drawing context so everything draws at the correct size
            ctx.scale(dpr, dpr);
            
            // Redraw after resize
            drawVisualization();
        }
        
        function startDrag(e) {
            isDragging = true;
            lastMouseX = e.offsetX;
            lastMouseY = e.offsetY;
        }
        
        function drag(e) {
            if (isDragging) {
                const deltaX = e.offsetX - lastMouseX;
                const deltaY = e.offsetY - lastMouseY;
                offsetX += deltaX;
                offsetY += deltaY;
                lastMouseX = e.offsetX;
                lastMouseY = e.offsetY;
                drawVisualization();
            }
        }
        
        function endDrag() {
            isDragging = false;
        }
        
        function zoom(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= zoomFactor;
            scale = Math.max(10, Math.min(1000, scale)); // Limit zoom range
            drawVisualization();
        }
        
        function latLonToPixels(lat, lon) {
            if (centerLat === null || centerLon === null) return { x: 0, y: 0 };
            
            // Convert lat/lon difference to meters (approximate)
            const latDiff = lat - centerLat;
            const lonDiff = lon - centerLon;
            
            // Rough conversion: 1 degree lat ≈ 111,000 meters
            // 1 degree lon ≈ 111,000 * cos(lat) meters
            const metersPerDegreeLat = 111000;
            const metersPerDegreeLon = 111000 * Math.cos(centerLat * Math.PI / 180);
            
            const meterX = lonDiff * metersPerDegreeLon;
            const meterY = -latDiff * metersPerDegreeLat; // Negative because canvas Y increases downward
            
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            return {
                x: displayWidth / 2 + meterX * scale + offsetX,
                y: displayHeight / 2 + meterY * scale + offsetY
            };
        }
        
        function drawRings() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            const centerX = displayWidth / 2 + offsetX;
            const centerY = displayHeight / 2 + offsetY;
            
            // Draw rings every 1 meter up to 50 meters
            for (let radius = 1; radius <= 50; radius++) {
                const pixelRadius = radius * scale;
                if (pixelRadius > Math.max(displayWidth, displayHeight) / 2) break;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, pixelRadius, 0, 2 * Math.PI);
                
                if (radius % 5 === 0) {
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = '#bdc3c7';
                    ctx.lineWidth = 1;
                }
                
                ctx.stroke();
                
                // Add distance labels for 5m intervals
                if (radius % 5 === 0 && pixelRadius > 20) {
                    ctx.fillStyle = '#7f8c8d';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${radius}m`, centerX + pixelRadius * 0.707, centerY - pixelRadius * 0.707);
                }
            }
        }
        
        function drawFixes() {
            if (fixes.length === 0) return;
            
            // Draw trace lines
            if (fixes.length > 1) {
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                
                for (let i = 1; i < fixes.length; i++) {
                    const prev = latLonToPixels(fixes[i-1].lat, fixes[i-1].lon);
                    const curr = latLonToPixels(fixes[i].lat, fixes[i].lon);
                    
                    if (i === 1) {
                        ctx.moveTo(prev.x, prev.y);
                    }
                    ctx.lineTo(curr.x, curr.y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Skip drawing individual fix points - only show traces
            
            // Highlight the latest fix with smaller highlight ring
            if (fixes.length > 0) {
                const latest = fixes[fixes.length - 1];
                const pos = latLonToPixels(latest.lat, latest.lon);
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 7, 0, 2 * Math.PI);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw crosshairs for current fix
                const displayWidth = canvas.clientWidth;
                const displayHeight = canvas.clientHeight;
                
                ctx.beginPath();
                // Vertical line (full height)
                ctx.moveTo(pos.x, 0);
                ctx.lineTo(pos.x, displayHeight);
                // Horizontal line (full width)
                ctx.moveTo(0, pos.y);
                ctx.lineTo(displayWidth, pos.y);
                
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]); // Dashed lines
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            }
        }
        
        function drawVisualization() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            
            // Draw background
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(0, 0, displayWidth, displayHeight);
            
            if (centerLat !== null && centerLon !== null) {
                drawRings();
                drawFixes();
                
                // Draw center marker
                const displayWidth = canvas.clientWidth;
                const displayHeight = canvas.clientHeight;
                const centerX = displayWidth / 2 + offsetX;
                const centerY = displayHeight / 2 + offsetY;
                ctx.beginPath();
                ctx.moveTo(centerX - 10, centerY);
                ctx.lineTo(centerX + 10, centerY);
                ctx.moveTo(centerX, centerY - 10);
                ctx.lineTo(centerX, centerY + 10);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw stability and drift table in upper left corner
            drawStabilityTable();
            
            // Draw pie chart in upper right corner
            drawPieChartOnCanvas();
            
            // Draw distance distribution bar chart in bottom left corner
            drawDistanceBarChart();
        }
        
        function updateConnectionStatus(online, message) {
            const statusIndicator = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');
            
            if (online) {
                statusIndicator.className = 'status-indicator status-online';
                statusText.textContent = message || ('HTTP: Connected to ' + ESP_IP);
            } else {
                statusIndicator.className = 'status-indicator status-offline';
                statusText.textContent = message || ('HTTP: Disconnected from ' + ESP_IP);
            }
        }
        
        function updateWebSocketStatus(status, message) {
            const statusIndicator = document.getElementById('websocket-status');
            const statusText = document.getElementById('websocket-text');
            
            switch(status) {
                case 'connecting':
                    statusIndicator.className = 'status-indicator status-offline';
                    statusText.textContent = 'WebSocket: Connecting...';
                    break;
                case 'connected':
                    statusIndicator.className = 'status-indicator status-online';
                    statusText.textContent = 'WebSocket: Connected';
                    break;
                case 'disconnected':
                    statusIndicator.className = 'status-indicator status-offline';
                    statusText.textContent = message || 'WebSocket: Disconnected';
                    break;
                case 'error':
                    statusIndicator.className = 'status-indicator status-offline';
                    statusText.textContent = 'WebSocket: Error - ' + (message || 'Connection failed');
                    break;
            }
        }
        
        function updateCurrentData(data) {
            document.getElementById('current-lat').textContent = data.lat ? data.lat.toFixed(6) : '--';
            document.getElementById('current-lon').textContent = data.lon ? data.lon.toFixed(6) : '--';
            document.getElementById('current-ele').textContent = data.ele ? data.ele.toFixed(1) + 'm' : '--';
            document.getElementById('current-siv').textContent = data.siv || '--';
            document.getElementById('current-type').textContent = data.type || '--';
            document.getElementById('current-hdop').textContent = data.hdop ? data.hdop.toFixed(2) : '--';
            document.getElementById('current-rssi').textContent = data.rssi ? data.rssi + 'dBm' : '--';
            document.getElementById('current-time').textContent = data.esptime ? data.esptime.toFixed(1) + 's' : '--';
        }
        
        function processGPSData(data) {
            // Only add if we have valid coordinates
            if (data.lat && data.lon) {
                // Set center to first fix
                if (centerLat === null || centerLon === null) {
                    centerLat = data.lat;
                    centerLon = data.lon;
                }
                
                const newFix = {
                    lat: data.lat,
                    lon: data.lon,
                    ele: data.ele,
                    type: data.type,
                    siv: data.siv,
                    hdop: data.hdop,
                    rssi: data.rssi,
                    esptime: data.esptime,
                    timestamp: Date.now()
                };
                
                // Add new fix
                fixes.push(newFix);
                
                // Update stability metrics
                updateStabilityMetrics(newFix);
                
                // Update fix type statistics
                updateFixTypeStats(newFix);
                
                drawVisualization();
            }
            
            updateCurrentData(data);
            document.getElementById('fix-count').textContent = `Fixes: ${fixes.length}`;
            document.getElementById('last-update').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
        }
        
        async function fetchData() {
            // Your ESP doesn't seem to have HTTP JSON endpoints, only WebSocket /json
            // So we'll disable HTTP polling and rely on WebSocket
            console.log('HTTP polling disabled - your ESP uses WebSocket /json only');
            updateConnectionStatus(false, 'HTTP not available - using WebSocket only');
            return;
            
            // If you add HTTP endpoints to your ESP later, uncomment below:
            /*
            const endpoints = ['/data', '/json', '/api', '/gps', '/'];
            
            for (const endpoint of endpoints) {
                try {
                    const response = await fetch(`http://${ESP_IP}${endpoint}`, {
                        mode: 'cors',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const contentType = response.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            const data = await response.json();
                            console.log(`HTTP success via ${endpoint}:`, data);
                            processGPSData(data);
                            updateConnectionStatus(true);
                            return;
                        }
                    }
                    
                } catch (error) {
                    console.log(`Failed to fetch from ${endpoint}:`, error.message);
                }
            }
            
            console.error('All HTTP endpoints failed');
            updateConnectionStatus(false);
            */
        }
        
        function initWebSocket() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close();
            }
            
            // Use only the known working path /json (ESP serves WebSocket on /json)
            const wsPaths = ['/json'];
            console.log('Connecting to known working WebSocket path: /json');
            tryWebSocketConnection(0, wsPaths);
        }
        
        function tryWebSocketConnection(pathIndex, wsPaths) {
            if (pathIndex >= wsPaths.length) {
                console.error('WebSocket connection failed on /json path');
                updateWebSocketStatus('error', 'ESP WebSocket /json not available - Check ESP status');
                return;
            }
            
            const wsUrl = 'ws://' + ESP_IP + wsPaths[pathIndex];
            updateWebSocketStatus('connecting', `Trying ${wsPaths[pathIndex]}...`);
            console.log('Attempting WebSocket connection to:', wsUrl);
            
            try {
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function(event) {
                    console.log('WebSocket connected successfully');
                    console.log('WebSocket readyState:', websocket.readyState);
                    updateWebSocketStatus('connected');
                    wsReconnectAttempts = 0;
                    updateWebSocketInfo();
                    
                    // Clear any existing reconnect interval
                    if (wsReconnectInterval) {
                        clearInterval(wsReconnectInterval);
                        wsReconnectInterval = null;
                    }
                    
                    // Send a test message to confirm connection
                    if (websocket.readyState === WebSocket.OPEN) {
                        console.log('Sending connection confirmation...');
                        websocket.send('{"type":"connect","message":"Dashboard connected"}');
                    }
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('WebSocket data received:', data);
                        processGPSData(data);
                        document.getElementById('last-update').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
                    } catch (error) {
                        console.error('Error parsing WebSocket data:', error);
                        document.getElementById('last-update').textContent = 'Last updated: Parse Error';
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                    updateWebSocketInfo();
                    
                    if (event.code === 1000) {
                        updateWebSocketStatus('disconnected', 'Connection closed normally');
                    } else if (event.code === 1006 && pathIndex < wsPaths.length - 1) {
                        // Try next path
                        console.log(`Path ${wsPaths[pathIndex]} failed, trying next...`);
                        setTimeout(() => tryWebSocketConnection(pathIndex + 1, wsPaths), 1000);
                    } else {
                        updateWebSocketStatus('disconnected', `Connection lost (Code: ${event.code})`);
                        attemptWebSocketReconnect();
                    }
                };
                
                websocket.onerror = function(error) {
                    console.error('WebSocket error occurred:', error);
                    console.error('WebSocket URL was:', wsUrl);
                    console.error('Error event details:', {
                        type: error.type,
                        target: error.target,
                        currentTarget: error.currentTarget
                    });
                    // Don't update status here, let onclose handle it
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                console.error('WebSocket creation error details:', error.message);
                
                // Try next path if available
                if (pathIndex < wsPaths.length - 1) {
                    setTimeout(() => tryWebSocketConnection(pathIndex + 1, wsPaths), 1000);
                } else {
                    updateWebSocketStatus('error', 'Failed to create connection - ' + error.message);
                    attemptWebSocketReconnect();
                }
            }
        }
        
        function attemptWebSocketReconnect() {
            if (wsReconnectAttempts >= maxReconnectAttempts) {
                updateWebSocketStatus('error', `Max reconnection attempts (${maxReconnectAttempts}) reached`);
                return;
            }
            
            if (wsReconnectInterval) {
                return; // Already attempting to reconnect
            }
            
            wsReconnectAttempts++;
            const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts - 1), 30000); // Exponential backoff, max 30s
            
            updateWebSocketStatus('disconnected', `Reconnecting in ${Math.ceil(delay/1000)}s (attempt ${wsReconnectAttempts}/${maxReconnectAttempts})`);
            
            wsReconnectInterval = setTimeout(() => {
                wsReconnectInterval = null;
                initWebSocket();
            }, delay);
        }
        
        function updateWebSocketInfo() {
            const readyStateText = {
                0: 'CONNECTING',
                1: 'OPEN',
                2: 'CLOSING',
                3: 'CLOSED'
            };
            
            // WebSocket info elements removed from simplified UI
        }
        
        async function testConnectivity() {
            console.log('=== CONNECTIVITY TEST START ===');
            console.log('ESP IP:', ESP_IP);
            
            // Test 1: Basic HTTP connectivity
            try {
                console.log('Testing basic HTTP connectivity...');
                const response = await fetch(`http://${ESP_IP}/`, { 
                    method: 'GET',
                    mode: 'no-cors' // Try no-cors mode first
                });
                console.log('Basic HTTP test - Response received (no-cors mode)');
            } catch (error) {
                console.error('Basic HTTP test failed:', error);
            }
            
            // Test 2: HTTP data endpoint
            try {
                console.log('Testing HTTP data endpoint...');
                const response = await fetch(`http://${ESP_IP}/data`);
                console.log('HTTP data endpoint - Status:', response.status);
                console.log('HTTP data endpoint - Headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('HTTP data endpoint - Data received:', data);
                } else {
                    console.error('HTTP data endpoint - Bad status:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('HTTP data endpoint test failed:', error);
            }
            
            // Test 3: WebSocket connectivity
            try {
                console.log('Testing WebSocket connectivity...');
                const testWs = new WebSocket(`ws://${ESP_IP}/ws`);
                
                testWs.onopen = function(event) {
                    console.log('WebSocket test - Connection opened successfully');
                    testWs.close(1000, 'Test completed');
                };
                
                testWs.onclose = function(event) {
                    console.log('WebSocket test - Connection closed:', event.code, event.reason);
                };
                
                testWs.onerror = function(error) {
                    console.error('WebSocket test - Connection failed:', error);
                };
                
                // Close test connection after 5 seconds if still open
                setTimeout(() => {
                    if (testWs.readyState === WebSocket.OPEN) {
                        testWs.close(1000, 'Test timeout');
                    }
                }, 5000);
                
            } catch (error) {
                console.error('WebSocket test failed to create connection:', error);
            }
            
            console.log('=== CONNECTIVITY TEST END ===');
            alert('Connectivity test running - check browser console (F12) for detailed results');
        }
        
        async function testManualEndpoint() {
            const endpoint = document.getElementById('manual-endpoint').value || '/data';
            console.log(`Testing manual endpoint: ${endpoint}`);
            
            try {
                const response = await fetch(`http://${ESP_IP}${endpoint}`);
                console.log(`Manual test ${endpoint} - Status:`, response.status);
                console.log(`Manual test ${endpoint} - Headers:`, [...response.headers.entries()]);
                
                if (response.ok) {
                    const text = await response.text();
                    console.log(`Manual test ${endpoint} - Response:`, text);
                    
                    try {
                        const data = JSON.parse(text);
                        console.log(`Manual test ${endpoint} - Parsed JSON:`, data);
                        alert(`Success! Got JSON data from ${endpoint}. Check console for details.`);
                    } catch (e) {
                        console.log(`Manual test ${endpoint} - Not JSON, raw text:`, text);
                        alert(`Got response from ${endpoint} but it's not JSON. Check console.`);
                    }
                } else {
                    alert(`HTTP ${response.status} from ${endpoint}`);
                }
            } catch (error) {
                console.error(`Manual test ${endpoint} failed:`, error);
                alert(`Failed to connect to ${endpoint}: ${error.message}`);
            }
        }
        
        function testManualWebSocket() {
            const wsPath = document.getElementById('manual-ws-path').value || '/ws';
            const wsUrl = `ws://${ESP_IP}${wsPath}`;
            console.log(`Testing manual WebSocket: ${wsUrl}`);
            
            const testWs = new WebSocket(wsUrl);
            
            testWs.onopen = function(event) {
                console.log(`Manual WebSocket test - ${wsPath} opened successfully`);
                alert(`WebSocket connection to ${wsPath} successful!`);
                testWs.close(1000, 'Manual test completed');
            };
            
            testWs.onmessage = function(event) {
                console.log(`Manual WebSocket test - Message received:`, event.data);
            };
            
            testWs.onclose = function(event) {
                console.log(`Manual WebSocket test - ${wsPath} closed:`, event.code, event.reason);
            };
            
            testWs.onerror = function(error) {
                console.error(`Manual WebSocket test - ${wsPath} failed:`, error);
                alert(`WebSocket connection to ${wsPath} failed. Check console.`);
            };
            
            // Auto-close after 5 seconds
            setTimeout(() => {
                if (testWs.readyState === WebSocket.OPEN) {
                    testWs.close(1000, 'Manual test timeout');
                }
            }, 5000);
        }
        
        function updateStabilityMetrics(newFix) {
            const now = Date.now();
            
            // Add to short term (last N fixes)
            stabilityMetrics.shortTerm.fixes.push(newFix);
            if (stabilityMetrics.shortTerm.fixes.length > stabilityMetrics.shortTerm.window) {
                stabilityMetrics.shortTerm.fixes.shift();
            }
            
            // Add to time-based windows
            ['oneMinute', 'fiveMinute', 'oneHour'].forEach(period => {
                const beforeCount = stabilityMetrics[period].fixes.length;
                stabilityMetrics[period].fixes.push(newFix);
                
                // Remove old fixes outside the time window
                const cutoffTime = now - stabilityMetrics[period].window;
                stabilityMetrics[period].fixes = stabilityMetrics[period].fixes.filter(
                    fix => fix.timestamp >= cutoffTime
                );
                const afterCount = stabilityMetrics[period].fixes.length;
                
                if (beforeCount !== afterCount - 1) {
                    console.log(`${period}: removed ${beforeCount - afterCount + 1} old fixes, now has ${afterCount} fixes`);
                }
            });
            
            // Calculate and display metrics
            calculateStabilityMetrics();
        }
        
        function calculateStabilityMetrics() {
            // Short term stability (RMS of last 10 fixes)
            const shortTermStability = calculateRMSError(stabilityMetrics.shortTerm.fixes);
            stabilityData.short = shortTermStability >= 0 ? `±${shortTermStability.toFixed(3)}m` : '--';
            
            // Time-based stability
            const oneMinStability = calculateRMSError(stabilityMetrics.oneMinute.fixes);
            stabilityData.oneMin = oneMinStability >= 0 ? `±${oneMinStability.toFixed(3)}m` : '--';
                
            const fiveMinStability = calculateRMSError(stabilityMetrics.fiveMinute.fixes);
            stabilityData.fiveMin = fiveMinStability >= 0 ? `±${fiveMinStability.toFixed(3)}m` : '--';
                
            const oneHourStability = calculateRMSError(stabilityMetrics.oneHour.fixes);
            stabilityData.oneHour = oneHourStability >= 0 ? `±${oneHourStability.toFixed(3)}m` : '--';
            
            // Debug: Log fix counts for each period
            console.log('Fix counts - 1min:', stabilityMetrics.oneMinute.fixes.length, 
                       '5min:', stabilityMetrics.fiveMinute.fixes.length, 
                       '1hr:', stabilityMetrics.oneHour.fixes.length);
            
            // Calculate drift (movement of mean position over time)
            calculateDriftMetrics();
        }
        
        function calculateRMSError(fixArray) {
            if (fixArray.length < 2) return -1;
            
            // Calculate mean position
            const meanLat = fixArray.reduce((sum, fix) => sum + fix.lat, 0) / fixArray.length;
            const meanLon = fixArray.reduce((sum, fix) => sum + fix.lon, 0) / fixArray.length;
            
            // Calculate RMS distance from mean
            const sumSquaredDistances = fixArray.reduce((sum, fix) => {
                const distance = calculateDistance(fix.lat, fix.lon, meanLat, meanLon);
                return sum + (distance * distance);
            }, 0);
            
            return Math.sqrt(sumSquaredDistances / fixArray.length);
        }
        
        function calculateDriftMetrics() {
            // 1 minute drift
            const oneMinDrift = calculateDrift(stabilityMetrics.oneMinute.fixes);
            stabilityData.driftOneMin = oneMinDrift >= 0 ? `${oneMinDrift.toFixed(3)}m` : '--';
                
            // 5 minute drift  
            const fiveMinDrift = calculateDrift(stabilityMetrics.fiveMinute.fixes);
            stabilityData.driftFiveMin = fiveMinDrift >= 0 ? `${fiveMinDrift.toFixed(3)}m` : '--';
                
            // 1 hour drift
            const oneHourDrift = calculateDrift(stabilityMetrics.oneHour.fixes);
            stabilityData.driftOneHour = oneHourDrift >= 0 ? `${oneHourDrift.toFixed(3)}m` : '--';
        }
        
        function calculateDrift(fixArray) {
            if (fixArray.length < 2) return -1;
            
            // Get first and last fix positions
            const firstFix = fixArray[0];
            const lastFix = fixArray[fixArray.length - 1];
            
            // Calculate distance between first and last positions
            return calculateDistance(firstFix.lat, firstFix.lon, lastFix.lat, lastFix.lon);
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Convert lat/lon difference to meters (approximate)
            const latDiff = lat2 - lat1;
            const lonDiff = lon2 - lon1;
            
            // Rough conversion: 1 degree lat ≈ 111,000 meters
            // 1 degree lon ≈ 111,000 * cos(lat) meters
            const metersPerDegreeLat = 111000;
            const metersPerDegreeLon = 111000 * Math.cos(lat1 * Math.PI / 180);
            
            const meterY = latDiff * metersPerDegreeLat;
            const meterX = lonDiff * metersPerDegreeLon;
            
            return Math.sqrt(meterX * meterX + meterY * meterY);
        }
        
        function drawStabilityTable() {
            const margin = 15;
            const tableWidth = 280;
            const tableHeight = 110;
            const rowHeight = 22;
            const headerHeight = 25;
            
            // Draw background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(margin, margin, tableWidth, tableHeight);
            
            // Draw border
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.strokeRect(margin, margin, tableWidth, tableHeight);
            
            // Column widths
            const col1Width = 90;  // Period
            const col2Width = 95;  // Stability
            const col3Width = 95;  // Drift
            
            // Draw header background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(margin + 1, margin + 1, tableWidth - 2, headerHeight - 1);
            
            // Draw column separators
            ctx.beginPath();
            ctx.moveTo(margin + col1Width, margin);
            ctx.lineTo(margin + col1Width, margin + tableHeight);
            ctx.moveTo(margin + col1Width + col2Width, margin);
            ctx.lineTo(margin + col1Width + col2Width, margin + tableHeight);
            ctx.stroke();
            
            // Draw row separators
            for (let i = 1; i <= 4; i++) {
                const y = margin + headerHeight + (i - 1) * rowHeight;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(margin + tableWidth, y);
                ctx.stroke();
            }
            
            // Draw headers
            ctx.fillStyle = '#495057';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Period', margin + 8, margin + 17);
            ctx.textAlign = 'center';
            ctx.fillText('Stability (RMS)', margin + col1Width + col2Width/2, margin + 17);
            ctx.fillText('Drift', margin + col1Width + col2Width + col3Width/2, margin + 17);
            
            // Data rows
            const rows = [
                { label: 'Short (10 fixes)', stability: stabilityData.short, drift: '--' },
                { label: '1 Minute', stability: stabilityData.oneMin, drift: stabilityData.driftOneMin },
                { label: '5 Minutes', stability: stabilityData.fiveMin, drift: stabilityData.driftFiveMin },
                { label: '1 Hour', stability: stabilityData.oneHour, drift: stabilityData.driftOneHour }
            ];
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#212529';
            
            rows.forEach((row, index) => {
                const y = margin + headerHeight + index * rowHeight + 14;
                
                // Period label
                ctx.textAlign = 'left';
                ctx.fillText(row.label, margin + 8, y);
                
                // Stability value
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText(row.stability, margin + col1Width + col2Width/2, y);
                
                // Drift value
                ctx.fillText(row.drift, margin + col1Width + col2Width + col3Width/2, y);
                
                ctx.font = '14px Arial';
            });
        }
        
        function updateFixTypeStats(newFix) {
            const fixType = newFix.type || 0;
            
            // Initialize if first time seeing this fix type
            if (!fixTypeStats[fixType]) {
                fixTypeStats[fixType] = { count: 0, firstSeen: Date.now() };
            }
            
            fixTypeStats[fixType].count++;
            // Pie chart will be redrawn with the main canvas
        }
        
        function drawPieChartOnCanvas() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            // Position in upper right corner
            const chartSize = 180;
            const chartRadius = 67;
            const chartX = displayWidth - chartSize - 15;
            const chartY = 15;
            const centerX = chartX + chartSize / 2;
            const centerY = chartY + chartRadius + 10;
            
            // Calculate total fixes
            const totalFixes = Object.values(fixTypeStats).reduce((sum, stat) => sum + stat.count, 0);
            
            if (totalFixes === 0) {
                // Draw empty circle with message
                ctx.beginPath();
                ctx.arc(centerX, centerY, chartRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No GPS', centerX, centerY - 5);
                ctx.fillText('fixes yet', centerX, centerY + 5);
                return;
            }
            
            // Fix type names
            const fixTypeNames = {
                0: 'No Fix',
                1: 'GPS fix', 
                2: 'DGPS',
                3: '??',
                4: 'RTK fix',
                5: 'RTK float'
            };
            
            // Sort fix types by count (largest first)
            const sortedTypes = Object.entries(fixTypeStats)
                .sort(([,a], [,b]) => b.count - a.count);
            
            let currentAngle = -Math.PI / 2; // Start at top
            
            sortedTypes.forEach(([fixType, stats]) => {
                const percentage = (stats.count / totalFixes) * 100;
                const sliceAngle = (stats.count / totalFixes) * 2 * Math.PI;
                const color = fixColors[fixType] || '#95a5a6';
                
                // Draw pie slice
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, chartRadius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Add percentage label if slice is large enough
                if (percentage > 10) {
                    const labelAngle = currentAngle + sliceAngle / 2;
                    const labelX = centerX + Math.cos(labelAngle) * (chartRadius * 0.7);
                    const labelY = centerY + Math.sin(labelAngle) * (chartRadius * 0.7);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(percentage.toFixed(0) + '%', labelX, labelY);
                }
                
                currentAngle += sliceAngle;
            });
            
            // Draw compact legend below pie chart
            let legendY = centerY + chartRadius + 15;
            ctx.font = '8px Arial';
            ctx.textAlign = 'left';
            
            sortedTypes.slice(0, 3).forEach(([fixType, stats]) => { // Show only top 3 types
                const percentage = (stats.count / totalFixes) * 100;
                const color = fixColors[fixType] || '#95a5a6';
                const typeName = fixTypeNames[fixType] || `Type ${fixType}`;
                
                // Draw color indicator
                ctx.fillStyle = color;
                ctx.fillRect(chartX + 5, legendY - 6, 8, 8);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(chartX + 5, legendY - 6, 8, 8);
                
                // Draw text
                ctx.fillStyle = '#333';
                ctx.fillText(`${typeName.slice(0, 8)}: ${percentage.toFixed(0)}%`, chartX + 18, legendY);
                
                legendY += 12;
            });
        }
        
        function drawDistanceBarChart() {
            if (fixes.length === 0 || centerLat === null || centerLon === null) {
                console.log('Bar chart not drawn - no fixes or center point');
                return;
            }
            
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            console.log('Drawing bar chart at', displayWidth, displayHeight);
            
            // Position at bottom spanning full canvas width
            const chartWidth = displayWidth - 30; // Use full width minus margins
            const chartHeight = 120; // Reduce height since it's spanning width
            const chartX = 15;
            const chartY = displayHeight - chartHeight - 15;
            const maxBars = 50; // Show up to 50 decimeter intervals (5 meters)
            const barWidth = Math.max(8, Math.floor((chartWidth - 40) / maxBars) - 1); // Dynamic bar width with better spacing
            
            // Calculate distances from starting point (first fix) in decimeters
            const startFix = fixes[0];
            const distanceBins = new Array(maxBars).fill(0);
            
            // Calculate current fix distance for highlighting
            let currentFixBin = -1;
            if (fixes.length > 0) {
                const currentFix = fixes[fixes.length - 1];
                const currentDistance = calculateDistance(startFix.lat, startFix.lon, currentFix.lat, currentFix.lon);
                const currentDecimeters = Math.floor(currentDistance * 10);
                currentFixBin = Math.min(currentDecimeters, maxBars - 1);
            }
            
            fixes.forEach(fix => {
                const distance = calculateDistance(startFix.lat, startFix.lon, fix.lat, fix.lon);
                const decimeters = Math.floor(distance * 10); // Convert meters to decimeters
                const binIndex = Math.min(decimeters, maxBars - 1); // Cap at max bars
                distanceBins[binIndex]++;
            });
            
            // Find max count for scaling
            const maxCount = Math.max(...distanceBins);
            console.log('Distance bins:', distanceBins, 'Max count:', maxCount);
            if (maxCount === 0) return;
            
            // Draw background for visibility
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(chartX - 5, chartY - 10, chartWidth + 10, chartHeight + 15);
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.strokeRect(chartX - 5, chartY - 10, chartWidth + 10, chartHeight + 15);
            
            // Draw bars
            const barAreaHeight = chartHeight - 40; // Leave space for labels in shorter chart
            
            distanceBins.forEach((count, index) => {
                if (count === 0) return;
                
                const barHeight = (count / maxCount) * barAreaHeight;
                const x = chartX + 20 + index * (barWidth + 1);
                const y = chartY + chartHeight - barHeight - 30;
                
                // Draw bar with highlighting for current fix position
                const isActiveBin = (index === currentFixBin);
                ctx.fillStyle = isActiveBin ? '#e74c3c' : '#3498db'; // Red for active, blue for others
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Add glow effect for active bar
                if (isActiveBin) {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, barWidth, barHeight);
                }
                
                // Draw count on top of bar if there's space
                if (barHeight > 20 && barWidth > 10) {
                    ctx.fillStyle = '#fff';
                    const fontSize = Math.min(14, barWidth);
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(count.toString(), x + barWidth/2, y + 18);
                }
                
                // Draw decimeter label at bottom (only every 10 decimeters or last bar)
                if (index % 10 === 0 || index === maxBars - 1) {
                    ctx.fillStyle = '#333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    const label = index === maxBars - 1 ? `${index}+` : (index / 10).toFixed(1) + 'm';
                    ctx.fillText(label, x + barWidth/2, chartY + chartHeight - 15);
                }
            });
        }
        
        function clearFixes() {
            fixes = [];
            centerLat = null;
            centerLon = null;
            offsetX = 0;
            offsetY = 0;
            scale = 200;
            
            // Clear stability metrics
            stabilityMetrics = {
                shortTerm: { fixes: [], window: 10 },
                oneMinute: { fixes: [], window: 60000 },
                fiveMinute: { fixes: [], window: 300000 },
                oneHour: { fixes: [], window: 3600000 }
            };
            
            // Clear fix type statistics
            fixTypeStats = {};
            
            // Reset stability data
            stabilityData = {
                short: '--',
                oneMin: '--',
                fiveMin: '--',
                oneHour: '--',
                driftOneMin: '--',
                driftFiveMin: '--',
                driftOneHour: '--'
            };
            
            document.getElementById('fix-count').textContent = 'Fixes: 0';
            drawVisualization();
        }
        
        function centerView() {
            offsetX = 0;
            offsetY = 0;
            scale = 200;
            drawVisualization();
        }
        
        function startAutoUpdate() {
            updateInterval = setInterval(fetchData, 2000);
        }
        
        function stopAutoUpdate() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        }
        
        function closeWebSocket() {
            if (websocket) {
                websocket.close(1000, 'Page unloading');
                websocket = null;
            }
            
            if (wsReconnectInterval) {
                clearTimeout(wsReconnectInterval);
                wsReconnectInterval = null;
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initCanvas();
            drawVisualization();
            
            // Show connection warning if not served from ESP
            if (window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost' || window.location.hostname === '') {
                const warning = document.getElementById('connection-warning');
                const espLink = document.getElementById('esp-link');
                warning.style.display = 'block';
                espLink.textContent = `http://${ESP_IP}/`;
                espLink.href = `http://${ESP_IP}/`;
            }
            
            console.log('ESP IP detected as:', ESP_IP);
            console.log('Page hostname:', window.location.hostname);
            
            // Try WebSocket first (your ESP only supports WebSocket at /json)
            initWebSocket();
            
            // Minimal HTTP polling (disabled for your setup)
            fetchData();
            
            // Start very slow HTTP polling as backup (mostly disabled)
            startAutoUpdate();
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            resizeCanvas();
        });
        
        // Clean up when page unloads
        window.addEventListener('beforeunload', function() {
            stopAutoUpdate();
            closeWebSocket();
        });
    </script>
</body>
</html>
